"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[750],{14255:function(e,t,o){o.r(t),o.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return h},default:function(){return d}});var n=o(87462),a=o(63366),i=(o(67294),o(3905)),r=["components"],s={sidebar_position:3},l="Robot Service Technical View",c={unversionedId:"rules/robot",id:"rules/robot",isDocsHomePage:!1,title:"Robot Service Technical View",description:"Blocking sequence",source:"@site/docs/rules/robot.md",sourceDirName:"rules",slug:"/rules/robot",permalink:"/docs/rules/robot",editUrl:"https://github.com/The-Microservice-Dungeon/docs/edit/main/docs/rules/robot.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Gameworld and Gameplay Guide",permalink:"/docs/rules/dungeon"},next:{title:"Trading Service Technical View",permalink:"/docs/rules/tradingService"}},h=[{value:"Blocking sequence",id:"blocking-sequence",children:[]},{value:"Fighting Sequence",id:"fighting-sequence",children:[]},{value:"Item usage sequence",id:"item-usage-sequence",children:[{value:"Fighting item",id:"fighting-item",children:[]}]},{value:"Mining sequence",id:"mining-sequence",children:[]},{value:"Movement sequence",id:"movement-sequence",children:[]},{value:"Regeneration sequence",id:"regeneration-sequence",children:[]},{value:"Upgrade sequence",id:"upgrade-sequence",children:[]},{value:"Robot and its data",id:"robot-and-its-data",children:[{value:"POST a robot",id:"post-a-robot",children:[]},{value:"PATCH robot data",id:"patch-robot-data",children:[]}]},{value:"Commands",id:"commands",children:[{value:"Valid commands are",id:"valid-commands-are",children:[]}]}],m={toc:h};function d(e){var t=e.components,o=(0,a.Z)(e,r);return(0,i.kt)("wrapper",(0,n.Z)({},m,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"robot-service-technical-view"},"Robot Service Technical View"),(0,i.kt)("h2",{id:"blocking-sequence"},"Blocking sequence"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"game service: issues the command which was received by the player"),(0,i.kt)("li",{parentName:"ul"},"robot service: processes the command and throws event according to the result")),(0,i.kt)("p",null,"No other service needs to know whether a planet is blocked or not so this information is managed within the robot context exclusively."),(0,i.kt)("h2",{id:"fighting-sequence"},"Fighting Sequence"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"game service: issues the command which was received by the player"),(0,i.kt)("li",{parentName:"ul"},"robot service: processes the command and throws event according to the result")),(0,i.kt)("p",null,"The event which is thrown as a result of the fighting sequence is puplic available information, as long as someone knows the robot uuid he can listen and use the gathered information.\nHiding the result behind a command uuid will obfuscate the information but results in problems for getting the needed information to the owner of the attacked robot (he doesn't know the command uuid and never will at the current draft of the command structure)"),(0,i.kt)("h2",{id:"item-usage-sequence"},"Item usage sequence"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"game service: issues the command which was received by the player"),(0,i.kt)("li",{parentName:"ul"},"robot service: processes the command, determines a random planet and throws events according to the result"),(0,i.kt)("li",{parentName:"ul"},"map service: provides a list of all planets")),(0,i.kt)("p",null,"(",(0,i.kt)("a",{parentName:"p",href:"https://github.com/The-Microservice-Dungeon/robot/tree/main/src/main/kotlin/com/msd/item/domain"},"https://github.com/The-Microservice-Dungeon/robot/tree/main/src/main/kotlin/com/msd/item/domain"),")"),(0,i.kt)("h3",{id:"fighting-item"},"Fighting item"),(0,i.kt)("p",null,"The received item type determines if a robot uuid or a planet uuid is expected. E.g. robot uuid for the targeted rocket and planet uuid for the nuke.\nRepair item"),(0,i.kt)("p",null,"The received item type determines if a robot uuid or a planet uuid is expected. E.g. robot uuid for a single repair and planet uuid for the repair swarm.\nMovement item (wormhole)"),(0,i.kt)("p",null,"The robot service requests a list of all planets from the map service and chooses a random one. The location of the robot is changes accordingly and a success event is thrown. Additionaly, the two events after a successful movement (refer to Robot movement sequence) are also thrown."),(0,i.kt)("h2",{id:"mining-sequence"},"Mining sequence"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"game service: issues the command which was received by the player"),(0,i.kt)("li",{parentName:"ul"},"robot service: processes the command, issues requests to map, processes the results and throws event according to the result"),(0,i.kt)("li",{parentName:"ul"},"map service: handles the amount of available resources")),(0,i.kt)("p",null,"All mining requests are received as a package from the game service and processed together. To determine if the requests are valid and the corresponding robot has the ability to mine the resource on its location, the robot service first requests the type of the resource from the map service.\nThe robot service then combines all valid requests for one planet and sends a mining request with the total amount per planet to the map service. Map then returns the amount which can be mined (requested value or below) and robot then distributes the received resources fairly between all participating robots for the planet."),(0,i.kt)("h2",{id:"movement-sequence"},"Movement sequence"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"game service: issues the command which was received by the player"),(0,i.kt)("li",{parentName:"ul"},"robot service: processes the command, issues request to map, checks if two planets are neighbors, processes the results and throws event according to the result"),(0,i.kt)("li",{parentName:"ul"},"map service: provides neighbors of a planet")),(0,i.kt)("p",null,"A successful result of the move has to incluse all planet data of the new position. This info has to be obfuscated so that not every player can just read the most recent planet data of all visited planets. Therefore the planet info has to be obfuscated via the command uuid.\nAfter a successful movement two events are thrown. The first one which indicates the success of the movement. It contains the remaining energy of the robot, the planet data of the target planet and the uuids of all robots located there. The second event is mapped to the command uuid and provides all neighbors for the target planet after a successful move.\nIf a player tries to move a robot which is on a blocked planet, the robot service will just throw an event to report the failure and that round is lost for that specific robot."),(0,i.kt)("h2",{id:"regeneration-sequence"},"Regeneration sequence"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"game service: issues the command which was received by the player"),(0,i.kt)("li",{parentName:"ul"},"robot service: processes the command and throws event according to the result")),(0,i.kt)("p",null,'Special case "regenerate twice the amount of energy on own spawn point" is probably out of scope because the robot service does not know the initial spawn location of the player - maybe there isn\'t one at all (game init: player has to buy his first robot and therefore has no designated personal spawn)'),(0,i.kt)("h2",{id:"upgrade-sequence"},"Upgrade sequence"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"game service: issues the command which was received by the player to the trading service"),(0,i.kt)("li",{parentName:"ul"},"trading service: processes the command, checks if position is a spacestation, checks if player has enough money, sends request to robot, receives answer from robot, adjusts wallet of player and throws success or failure event"),(0,i.kt)("li",{parentName:"ul"},"robot service: validate robot position and do the upgrade (answer is success or failure)")),(0,i.kt)("p",null,"The trading service has to handle the communication with the game service and has to throw the events which report the results.\nThe robot service only has to validate the position of the given robot and check if the bought upgrade is possible. If yes: do the upgrade and answer with success to the trading service and if no, answers with report of failure. The rest is handled by the trading service."),(0,i.kt)("p",null,"Upgrade Status: robot receives the data from trading if upgrades are bought, stores this and tracks the multiplier (which is dependant on the total bought upgrades for each robot)"),(0,i.kt)("h2",{id:"robot-and-its-data"},"Robot and its data"),(0,i.kt)("p",null,"(",(0,i.kt)("a",{parentName:"p",href:"https://github.com/The-Microservice-Dungeon/robot/blob/main/src/main/kotlin/com/msd/robot/application/RobotController.kt"},"https://github.com/The-Microservice-Dungeon/robot/blob/main/src/main/kotlin/com/msd/robot/application/RobotController.kt"),")"),(0,i.kt)("p",null,"The API provides GET for all attributes of a robot:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"(",(0,i.kt)("a",{parentName:"p",href:"https://github.com/The-Microservice-Dungeon/robot/blob/main/src/main/kotlin/com/msd/robot/domain/Robot.kt"},"https://github.com/The-Microservice-Dungeon/robot/blob/main/src/main/kotlin/com/msd/robot/domain/Robot.kt"),")")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"general: id, player, planet, alive")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"max stats of robot according to current upgrade status: maxHealth, maxEnergy, energyRegen, attackDamage, miningSpeed")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"current status of the robot: health, energy")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"current upgrade level: healthLevel, damageLevel, miningSpeedLevel, miningLevel, energyLevel, energyRegenLevel, storageLevel")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"object \u201cinventory\u201d with attributes: maxStorage, usedStorage, storedCoal, storedIron, storedGem, storedGold, storedPlatin (",(0,i.kt)("a",{parentName:"p",href:"https://github.com/The-Microservice-Dungeon/robot/blob/main/src/main/kotlin/com/msd/robot/domain/Inventory.kt"},"https://github.com/The-Microservice-Dungeon/robot/blob/main/src/main/kotlin/com/msd/robot/domain/Inventory.kt"),")"))),(0,i.kt)("h3",{id:"post-a-robot"},"POST a robot"),(0,i.kt)("p",null,"This is responsible for spawning a new robot. It should only be used by the trading service."),(0,i.kt)("p",null,"The expected properties are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"transaction_id"),(0,i.kt)("li",{parentName:"ul"},"player"),(0,i.kt)("li",{parentName:"ul"},"planet")),(0,i.kt)("p",null,"All expected properties are UUIDs. The robot service then creates the new robot with a newly generated uuid for the robot, the three received properties and standard values."),(0,i.kt)("h3",{id:"patch-robot-data"},"PATCH robot data"),(0,i.kt)("p",null,"This is the way to go if the game service converts commands to API calls and controls the actions. May be subject to chance depending on whether we get the respective command directly or reformed as API call."),(0,i.kt)("p",null,"Is used to change attributes of a specific robot. Used for trading, upgrading, mining, movement.\nExpected properties are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For movement: planet uuid")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For upgrading: healthLevel, damageLevel, miningSpeedLevel, miningLevel, energyLevel, energyRegenLevel, storageLevel as integer")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For mining and trading: storedCoal, storedIron, storedGem, storedGold, storedPlatin"))),(0,i.kt)("h2",{id:"commands"},"Commands"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"(",(0,i.kt)("a",{parentName:"li",href:"https://github.com/The-Microservice-Dungeon/robot/blob/main/src/main/kotlin/com/msd/command/application/CommandApplicationService.kt"},"https://github.com/The-Microservice-Dungeon/robot/blob/main/src/main/kotlin/com/msd/command/application/CommandApplicationService.kt"),")"),(0,i.kt)("li",{parentName:"ul"},"(",(0,i.kt)("a",{parentName:"li",href:"https://github.com/The-Microservice-Dungeon/robot/blob/main/src/main/kotlin/com/msd/command/application/CommandController.kt"},"https://github.com/The-Microservice-Dungeon/robot/blob/main/src/main/kotlin/com/msd/command/application/CommandController.kt"),")"),(0,i.kt)("li",{parentName:"ul"},"(",(0,i.kt)("a",{parentName:"li",href:"https://github.com/The-Microservice-Dungeon/robot/blob/main/src/main/kotlin/com/msd/robot/application/RobotApplicationService.kt"},"https://github.com/The-Microservice-Dungeon/robot/blob/main/src/main/kotlin/com/msd/robot/application/RobotApplicationService.kt"),")")),(0,i.kt)("p",null,"The path \u201c/commands\u201d is a endpoint to receive commands which are no specific API calls. These are all commands which the player issues to the game service which then will be forwarded to us together with a transaction id. They are received as a batch consisting of all commands of a phase."),(0,i.kt)("h3",{id:"valid-commands-are"},"Valid commands are"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"block\nmove\nfight\nmine\nregenerate\nuse-item-fighting\nuse-item-movement\n")))}d.isMDXComponent=!0}}]);